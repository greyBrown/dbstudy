-- 1. LOCATION_ID가 1700인 부서에 근무하는 사원들의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME을 조회하시오.
SELECT  E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_NAME
FROM  DEPARTMENTS D INNER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE D.LOCATION_ID=1700;

-- 2. DEPARTMENT_NAME이 'Executive'인 부서에 근무하는 사원들의 EMPLOYEE_ID, FIRST_NAME을 조회하시오.
SELECT E.EMPLOYEE_ID, E.FIRST_NAME
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE D.DEPARTMENT_NAME = 'Executive';            --조건절 테이블 별명 빼먹음! 결과가 달라지진 않지만 그래도~


-- 3. 모든 사원들의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME, STREET_ADDRESS, CITY를 조회하시오.
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_NAME, L.STREET_ADDRESS, L.CITY
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID RIGHT JOIN LOCATIONS L              --조인순서 다르게 함. 크게 더 나은가...? 아직은 아리까리
ON D.LOCATION_ID = L.LOCATION_ID;                                        --두번째 INNER 조인이 아니라 RIGHT 조인


-- 4. 사원이 근무 중인 부서를 대상으로 DEPARTMENT_NAME과 근무 중인 사원 수와 평균 연봉을 조회하시오.
SELECT D.DEPARTMENT_NAME, COUNT(E.EMPLOYEE_ID), FLOOR(AVG(E.SALARY))
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME;

-- 5. JOB_HISTORY 테이블에 존재하는 사원들을 대상으로 사원번호, 현재 JOB_ID, 예전 JOB_ID를 조회하시오.
SELECT E.EMPLOYEE_ID, E.JOB_ID AS 현재, H.JOB_ID AS 과거
FROM EMPLOYEES E INNER JOIN JOB_HISTORY H
ON E.EMPLOYEE_ID=H.EMPLOYEE_ID
WHERE E.JOB_ID != H.JOB_ID;                                 --WHERE절 안썼음. 바뀌지 않았는데 존재하는 사람들으 제외하기 위해 해당 조건문 추가해줌.


-- 6. 모든 사원들의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME을 조회하시오. 부서가 없는 사원의 부서명은 'None'으로 조회되도록 처리하시오.
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, NVL(D.DEPARTMENT_NAME, 'NONE')
FROM  DEPARTMENTS D RIGHT JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;                                --NVL 잘 쓰죠? 후후 부서가 없는 단서를 보고 외부 조인도 잘 달았다! 단서를 잘 추적하는게 중요...


-- 7. 모든 부서의 DEPARTMENT_NAME과 근무 중인 사원 수를 조회하시오. 근무하는 사원이 없으면 0으로 조회하시오.
SELECT D.DEPARTMENT_NAME, NVL(COUNT(E.EMPLOYEE_ID), 0)              --답지엔 NVL없음! 하지만 결과는 동일! 안써도 0이네..?
FROM  DEPARTMENTS D LEFT JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
ORDER BY D.DEPARTMENT_ID;                                            --미관상 ORDER BY 추가해줍니다.

-- 8. 모든 부서의 DEPARTMENT_ID, DEPARTMENT_NAME, STATE_PROVINCE, COUNTRY_NAME, REGION_NAME을 조회하시오. --컨트리로 REGION ID 공유
SELECT  D.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.STATE_PROVINCE, C.COUNTRY_NAME, R.REGION_NAME
FROM DEPARTMENTS D INNER JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID INNER JOIN COUNTRIES C                   --결과는 똑같음! 순서가 좀 다름
ON L.COUNTRY_ID = C.COUNTRY_ID INNER JOIN REGIONS R                       --조인순서 다름. REGION-COUNTRY-LOCATION 순서
ON C.REGION_ID = R.REGION_ID;                                                     -- 나는 LOCATION-COUNTRY-REGION 순서

SELECT D.DEPARTMENT_ID      AS 부서번호
     , D.DEPARTMENT_NAME    AS 부서명
     , L.STATE_PROVINCE     AS 주
     , C.COUNTRY_NAME       AS 국가
     , R.REGION_NAME        AS 대륙
  FROM REGIONS R INNER JOIN COUNTRIES C
    ON R.REGION_ID = C.REGION_ID INNER JOIN LOCATIONS L
    ON C.COUNTRY_ID = L.COUNTRY_ID INNER JOIN DEPARTMENTS D
    ON L.LOCATION_ID = D.LOCATION_ID;
